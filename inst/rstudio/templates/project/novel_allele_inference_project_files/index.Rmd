---
title: "Immcantation - enchantR"
subtitle: "Novel allele inference"
author: ""
date: "Updated: `r date()`"
knit: enchantr::render_book
site: bookdown::bookdown_site
documentclass: book
bibliography: "references.bib"
biblio-style: apalike
link-citations: yes
description: "enchantr clonal assignment"
output: enchantr::immcantation
params:
   input:
      label: "`input`: Path to repertoires files"
      input: file
      value: "https://yale.box.com/shared/static/dajikxtvbc3c5yw1o2v69fjtx5bh58r2.tsv"
   imgt_db:
      label: "`imgt_db`: Path to IMGT reference  database."
      input: file
      value: "https://raw.githubusercontent.com/nf-core/test-datasets/airrflow/database-cache/imgtdb_base.zip"
   species:
      label: "`species`"
      input: text
      value: "human"
   germline_min:
      label: "`germline_min`"
      input: numeric
      value: 200
   min_seqs:
      label: "`min_seqs`"
      input: numeric
      value: 50
   auto_mutrange:
      label: "`auto_mutrange`"
      input: checkbox
      value: TRUE
   mut_range:
      label: "`mut_range`"
      input: text
      value: "1:10"
   pos_range:
      label: "`pos_range`"
      input: text
      value: "1:312"
   pos_range_max:
      label: "`pos_range_max`"
      input: numeric
      value: NULL
   y_intercept:
      label: "`y_intercept`"
      input: numeric
      value: 0.125
   alpha:
      label: "`alpha`"
      input: numeric
      value: 0.05
   j_max:
      label: "`j_max`"
      input: numeric
      value: 0.15
   min_frac:
      label: "`min_frac`"
      input: numeric
      value: 0.75
   v_call:
      label: "`v_call`: Column name for V gene calls"
      input: text
      value: "v_call"
   j_call:
      label: "`j_call`: Column name for J gene calls"
      input: text
      value: "j_call"
   seq:
      label: "`seq`: Column name for sequence alignment"
      input: text
      value: "sequence_alignment"
   junction:
      label: "`junction`: Column name for junction sequence"
      input: text
      value: "junction"
   junction_length:
      label: "`junction_length`: Column name for junction length"
      input: text
      value: "junction_length"
   reassign:
      label: "`reassign`: Reassign sequences to personal genotype"
      input: checkbox
      value: FALSE
   outname:
      label: "`outname`"
      input: text
      value: "tigger"
   nproc:
      label: "`nproc`"
      input: numeric
      value: 1
   log:
      label: "`log`"
      input: text
      value: "command_log"
   outdir:
      label: "`outdir`: Output directory"
      input: text
      value: !r file.path(getwd(),'enchantr')
   date:
      label: "`date`: Run date"
      input: date
      value: !r format(Sys.time(), "%Y-%m-%d")
   logo:
      label: "`logo`: Path to report logo"
      input: file
      value: !r file.path("assets", "logo.png")
   logolink:
      label: "`logolink`: URL to be added to the logo"
      input: text
      value: "immcantation.org"
   echo:
      label: "`echo`: Show code in the report."
      input: checkbox
      value: TRUE
   cache:
      label: "`cache`: Use cached results"
      input: checkbox
      value: FALSE
editor_options:
   chunk_output_type: console
---

<div class="introduction_paragraph">
Novel Allele inference created by TIgGER.
</div>

```{r global-options, include=FALSE, cache=FALSE}
knitr::opts_chunk$set(fig.width=7, fig.height=4, fig.path = "figures/",
                      echo=params$echo,cache=params$cache,
                      warning=FALSE, message=FALSE,
                      eval.after="fig.cap",
                      out_dir=params$outdir,
                      eval.opts = c('eval', 'echo', 'fig.height', 'fig.width'))

# Libraries
suppressPackageStartupMessages(library("dplyr"))
suppressPackageStartupMessages(library("stringr"))
suppressPackageStartupMessages(library("tidyr"))
suppressPackageStartupMessages(library("airr"))
suppressPackageStartupMessages(library("enchantr"))
suppressPackageStartupMessages(library("tigger"))

if (!dir.exists(params[['outdir']])) {
    dir.create(params[['outdir']], recursive=T)
}

file.copy(params$logo,
          file.path(params$outdir,"assets", "logo.png"),
          recursive=T, overwrite=T)

```


```{r helper-functions, include=FALSE, cache=FALSE}

# Helper for light chain inference by gene range
infer_novel_light_chain <- function(db, germline_db, params) {
  gene_range <- tigger_upper_bound(db)
  purrr::map_dfr(seq_along(gene_range), function(i) {
    upper_range <- as.numeric(names(gene_range)[i])
    genes <- gene_range[i]
    sub_db <- db[stringi::stri_detect_regex(db[[params$v_call]], genes), ]
    if (nrow(sub_db) == 0) return(NULL)
    low_range <- min(sub_db$v_germline_start)
    novel_df <- try(findNovelAlleles(
      data = sub_db,
      germline_db = germline_db,
      pos_range = low_range:upper_range,
      v_call = params$v_call,
      j_call = params$j_call,
      seq = params$seq,
      junction = params$junction,
      junction_length = params$junction_length,
      nproc = params$nproc,
      germline_min = params$germline_min,
      min_seqs = params$min_seqs,
      y_intercept = params$y_intercept,
      alpha = params$alpha,
      j_max = params$j_max,
      min_frac = params$min_frac,
      auto_mutrange = params$auto_mutrange,
      mut_range = params$mut_range
    ))
    if (inherits(novel_df, "try-error")) return(NULL)
    novel_df
  })
}


```


# Input parameters

```{r input-parameters, results='asis'}
printParams(params)
```
```{r echo=FALSE, results='asis'}
print_table_caption(tag="input", text="Input parameters.")
save(params, file=file.path(params$outdir,"params.RData"))
```

# Read repertoires

```{r read-input}
# Read repertoire

cols_to_read <- unique(c("sequence_id", "productive", 
                         params$seq, params$v_call, params$j_call, 
                         params$junction, params$junction_length))

db <- read_rearrangement(params[['input']], col_select = cols_to_read)

if (!"locus" %in% colnames(db)) {
    db[['locus']] <- getLocus(db[[params$v_call]])
}

if (!is.null(params$outname)) {
    output_fn <- paste0(params$outname,"_novel-pass.tsv.gz")
    report_output_fn <- paste0(params$outname,"_novel_report.tsv")
} else {
    output_fn <- sub(".tsv$", "_novel-pass.tsv", basename(params$input))
    report_output_fn <- sub(".tsv$", "_novel_report.tsv", basename(params$input))
}

if (!is.null(params$log)) {
    log_fn <- paste0(params$log,".txt")
} else {
    log_fn <- sub("_novel-pass.tsv$", "_command_log.txt", basename(output_fn))
}

db <- db %>% dplyr::filter(.data[['productive']] == TRUE)
```

# Read Germline database

```{r read-germline}
# If it is a zip file or URL, run prepareIMGT; else use as is
if (grepl("\\.zip$", params$imgt_db) || grepl("^https?://", params$imgt_db)) {
   imgt_db <- prepareIMGT(params$imgt_db)
} else {
   imgt_db <- params$imgt_db
}

germline_db <- dowser::readIMGT(file.path(imgt_db,
                                params$species, "vdj"),
                               quiet=TRUE)
## filter the germline database to include only alleles of params$v_call
call_tag <- paste0(unique(db[['locus']]), toupper(substr(params$v_call, 1, 1)))
ref_output_fn <- paste0(params$species,"_",call_tag,"_novel.fasta")

germline_db <- germline_db[grepl(call_tag, names(germline_db))]
```

```{r log}
cat("START> InferNovelAlleles", file=log_fn, append=F)
cat(paste0("\nFILE> ",basename(params$input)), file=log_fn, append=T)
```

# Infer Novel alleles

In this section, novel alleles are inferred by identifying positions with unexpectedly high mutation frequencies compared to the germline reference. 

Additional filters are applied to reduce false positives from clonally-related sequences.

```{r infer-novel-alleles}

# Run TIgGER novel allele inference
if (all(db$locus == "IGH")) {
   # Heavy chain: run as usual
   novel <- try(findNovelAlleles(
      data = db,
      germline_db = germline_db,
      v_call = params$v_call,
      j_call = params$j_call,
      seq = params$seq,
      junction = params$junction,
      junction_length = params$junction_length,
      germline_min = params$germline_min,
      min_seqs = params$min_seqs,
      y_intercept = params$y_intercept,
      alpha = params$alpha,
      j_max = params$j_max,
      min_frac = params$min_frac,
      auto_mutrange = params$auto_mutrange,
      mut_range = params$mut_range,
      pos_range = params$pos_range,
      nproc = params$nproc
   ))
} else {
   # Light chain: run per gene-range
   novel <- infer_novel_light_chain(db, germline_db, params)
}
```

# Clean up novel allele inference results

```{r clean-up}

if (!inherits(novel, 'try-error') && nrow(novel) > 0) {
  novel <- tigger::selectNovel(novel) %>%
    dplyr::distinct(novel_imgt, .keep_all = TRUE) %>%
    dplyr::filter(!is.na(novel_imgt), nt_substitutions != '') %>%
    dplyr::mutate(gene = alakazam::getGene(germline_call, strip_d = FALSE)) %>%
    dplyr::group_by(gene) %>% dplyr::top_n(n = 2, wt = novel_imgt_count)

  SNP_XXXX <- check_repeated_snp_patterns(novel)
  novel <- novel[!SNP_XXXX, ]
  novel <- novel[!duplicated(novel[['polymorphism_call']]), ]
}

```

# Build new germline database with novel alleles

```{r build-reference}

if (nrow(novel) > 0) {
    # Build novel reference database
    novel_germline <- setNames(gsub('-', '.', novel[['novel_imgt']], fixed = TRUE), novel[['polymorphism_call']])
    germline_db <- c(germline_db, novel_germline)
}

```

# Reassign sequences to novel alleles (optional)

```{r reassign, eval=params$reassign}
if (params$reassign & !all(is.na(germline_db))) {
   # Read rearrangement data with all columns
   db <- read_rearrangement(params[['input']])

   # Reassign sequences to novel alleles. Only do it if novel alleles were found
   if (nrow(novel) > 0) {
        # TODO: check to add the option of path to aligner, and keep_gene
        # Using default params for now
        db <- reassignAlleles(db, 
                                germline_db = germline_db,
                                call = call_col, 
                                seq = params$seq_column)
   }
   
}
```

# Save results

```{r save-results}

# Save novel report (optional)

if(exists("novel") && nrow(novel) > 0) {
   write.table(novel, file = file.path(params$outdir, report_output_fn), row.names = FALSE, quote = FALSE, sep = '\t')
}

# Save personal reference if generated
if (!all(is.na(germline_db)) && exists("germline_db")) {
    tigger::writeFasta(germline_db,
                      file = file.path(params$outdir, ref_output_fn))
}

# Save reassigned database if generated
if (params$reassign & exists("db")) {
   write_rearrangement(db, 
                       file = file.path(params$outdir, output_fn))
}

```


```{r log-end}
cat("END> InferNovelAlleles", file=log_fn, append=T)
if(params$reassign && exists("db")){
   cat(paste0("\nOUTPUT> ", output_fn), file=log_fn, append=T)
}
if(exists("novel") && nrow(novel) > 0){
    cat(paste0("\nOUTPUT> ", report_output_fn), file=log_fn, append=T)
}
cat(paste0("\nOUTPUT> ",basename(ref_output_fn)), file=log_fn, append=T)
cat(paste0("\nNOVEL-ALLELES-DETECTED> ",nrow(novel)), file=log_fn, append=T)
```

```{r, child=c('versions.Rmd')}
```