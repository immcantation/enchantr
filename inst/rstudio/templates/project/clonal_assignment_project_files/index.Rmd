--- 
title: "Immcantation - enchantR"
subtitle: "Clonal Assignment"
author: ""
date: "Updated: `r date()`"
knit: enchantr::render_book
site: bookdown::bookdown_site
documentclass: book
bibliography: "references.bib"
biblio-style: apalike
link-citations: yes
description: "enchantr clonal assignment"
output: enchantr::immcantation
params:
   input: 
      label: "`input`: Path to repertoires files"
      input: file
      value: "https://yale.box.com/shared/static/dajikxtvbc3c5yw1o2v69fjtx5bh58r2.tsv"
   imgt_db:
      label: "`imgt_db`: Path to IMGT reference  database."
      input: file
      value: "https://raw.githubusercontent.com/nf-core/test-datasets/airrflow/database-cache/imgtdb_base.zip"
   species:
      label: "`species`"
      input: text
      value: "human"    
   force:
      label: "`force`: if clone_id already exists, overwrite (force=TRUE) or skip clone assignment and render the report (force=FALSE)."
      input: logical        
      value: !r FALSE       
   cloneby:
      label: "`cloneby`"
      input: text
      value: "subject_id"    
   singlecell:
      label: "`singlecell`"
      input: text
      value: NULL          
   threshold:
      label: "`threshold`"
      input: numeric
      value: 1
   outputby:
      label: "`outputby` name of the column in `input` that contains sample identifiers that will be used to split the output db." 
      input: text
      value: "sample_id"
   model:
      label: "`model`"
      input: text
      value: "hierarchical" 
   method:
       label: "`method`"
       input: text
       value: "nt"
   linkage:
       label: "`linkage`"
       input: text
       value: "single"
   outname:
      label: "`outname`"
      input: text
      value: "clonal-assignment"
   nproc:
      label: "`nproc`"
      input: numeric
      value: 1      
   log:
      label: "`log`"
      input: text
      value: "command_log"
   outdir:
      label: '`outdir`: Output directory'
      input: text
      value: !r file.path(getwd(),'enchantr')
   date: 
      label: '`date`: Run date'
      input: date
      value: !r format(Sys.time(), "%Y-%m-%d")
   logo:
      label: "`logo`: Path to report logo"
      input: file
      value: !r file.path("assets", "logo.png")
   logolink:
      label: "`logolink`: URL to be added to the logo"
      input: text
      value: "immcantation.org"
   echo: 
      label: '`echo`: Show code in the report.'
      input: checkbox
      value: TRUE
   cache:
      label: '`cache`: Use cached results'
      input: checkbox
      value: FALSE
editor_options: 
  chunk_output_type: console
---

<div class="introduction_paragraph">
Report of clonal assignment by Immcantation package <a href="https://enchantr.readthedocs.io/en/stable/" target="_blank">enchantR</a>. Immcantation package <a href="https://scoper.readthedocs.io/en/stable/" target="_blank">SCOPer</a> is used to assign clones. 
</div>

```{r global-options, include=FALSE, cache=FALSE}
knitr::opts_chunk$set(fig.width=7, fig.height=4, fig.path = "figures/",
                      echo=params$echo,cache=params$cache,
                      warning=FALSE, message=FALSE,
                      eval.after="fig.cap",
                      out_dir=params$outdir,
                      eval.opts = c('eval', 'echo', 'fig.height', 'fig.width'))

# Libraries
suppressPackageStartupMessages(library("DT"))
suppressPackageStartupMessages(library("dplyr"))
suppressPackageStartupMessages(library("stringr"))
suppressPackageStartupMessages(library("tidyr"))
suppressPackageStartupMessages(library("airr"))
suppressPackageStartupMessages(library("alakazam"))
suppressPackageStartupMessages(library("shazam"))
suppressPackageStartupMessages(library("scoper"))
suppressPackageStartupMessages(library("dowser"))
suppressPackageStartupMessages(library("enchantr"))
suppressPackageStartupMessages(library("ComplexHeatmap"))
suppressPackageStartupMessages(library("plotly"))
suppressPackageStartupMessages(library("fastcluster"))

if (!dir.exists(params[['outdir']])) {
    dir.create(params[['outdir']], recursive=T)
}

file.copy(params$logo,
          file.path(params$outdir,"assets", "logo.png"),
          recursive=T, overwrite=T)

singlecell <- params$singlecell
```


# Input parameters

```{r input-parameters, results='asis'}
printParams(params)
```
```{r echo=FALSE, results='asis'}
print_table_caption(tag="input", text="Input parameters.")
save(params, file=file.path(params$outdir,"params.RData"))
```

# Read repertoires
<div class="introduction_paragraph">
Tables summarizing number of sequences in the provided repertoires according to different characteristics.
</div>

```{r}
# Read repertoire
db <- readInput(params[['input']], col_select = NULL)

if (params$species =="auto") {
    if ("species" %in% colnames(db)) {
        species <- unique(db[['species']])
        if (length(species)>1) {
            stop("Multiple species detected. Only one allowed.")
        }
    } else  {
        stop("Can't detect species. The column `species` does not exist in `db`.")
    }
} else {
    species <- params$species
}

# Check for single cell label
if (!is.null(singlecell)) {
    if (singlecell %in% colnames(db)) {
         db[[ singlecell ]] <- as.logical(db[[ singlecell ]] )   
    } else {
        stop("`",singlecell, "` is not a valid field in `db`.")
    }
} else {
   singlecell <- "single_cell"
   db[[singlecell]] <- F
   if ("cell_id" %in% colnames(db)) {
       message("Setting `singlecell` using `cell_id`.") 
       db[[singlecell]][!db[['cell_id']] %in% c(NA, '')] <- T
   }

}

if (!"locus" %in% colnames(db)) {
    db[['locus']] <- getLocus(db[['v_call']])
}
heavy_chains <- isHeavyChain(db[['locus']])

if ("clone_id" %in% colnames(db)) {
    if (params$force) {
        # Reset if force
        warning("Overwritting clone_id.")
        db$clone_id <- NULL
    }   
    # Reset always if clone_id exists
    if ("clone_size_count" %in% colnames(db)) {    
        warning("Overwritting clone_size_count.")    
        db$clone_size_count <- NULL
    }
    if ("clone_size_freq" %in% colnames(db)) {    
        warning("Overwritting clone_size_freq.")    
        db$clone_size_freq <- NULL
    }
}

subject_levels <- str_sort(unique(db$subject_id), numeric = TRUE)
sample_levels  <- str_sort(unique(db$sample_id),  numeric = TRUE)
db <- db %>%
  mutate(
    subject_id = factor(subject_id, levels = subject_levels),
    sample_id  = factor(sample_id,  levels = sample_levels)
  ) %>%
  arrange(subject_id, sample_id) 
```

```{r}
input_size <- nrow(db)
input_sizes <- db %>%
    group_by(!!!rlang::syms(unique(c("input_file")))) %>%
    summarize(input_size=n())

# Track input size of the expected output groups, for the
# end of report summary
input_sizes_byoutput <- db %>%
    group_by(!!!rlang::syms(unique(params$outputby))) %>%
    mutate(
        num_input_files = length(unique(input_file)),
        input_files = paste(unique(input_file), collapse=",")
    ) %>%
    ungroup() %>%
    group_by(!!!rlang::syms(unique(c(params$outputby, "input_file", "num_input_files", "input_files")))) %>%
    summarize(
        input_size = n()
    )

```


Number of sequences loaded: `r input_size`. Number of heavy chain sequences loaded: `r sum(heavy_chains, na.rm=T)`.

```{r inputsamplesumary, results='asis', eval="tissue" %in% colnames(db)}
input_samples_summary <- db %>%
   group_by(sample_id, subject_id, tissue) %>%
   summarize(size = n()) 

subject_levels <- str_sort(unique(input_samples_summary$subject_id), numeric = TRUE)
sample_levels  <- str_sort(unique(input_samples_summary$sample_id),  numeric = TRUE)
input_samples_summary <- input_samples_summary %>%
  mutate(
    subject_id = factor(subject_id, levels = subject_levels),
    sample_id  = factor(sample_id,  levels = sample_levels)
  ) %>%
  arrange(subject_id, sample_id,tissue) %>%
  mutate(
    subject_id = as.character(subject_id),
    sample_id  = as.character(sample_id)
  )

eetable(input_samples_summary)$table
```
```{r echo=FALSE, results='asis', eval="tissue" %in% colnames(db)}
print_table_caption(tag="input_samples_summary", text="Input samples summary.")
```


## Sequences per locus

```{r inputlocussumary, results='asis'}
input_locus_summary <- db %>%
  group_by(!!!rlang::syms(unique(c("sample_id", "subject_id", params$cloneby, "locus")))) %>%
   summarize(n=n(), .groups="drop") %>%
   pivot_wider(names_from=locus, values_from=n) %>%
   rowwise() %>%
   mutate(Total = sum(!!!rlang::syms(unique(db[['locus']]))))

total <- data.frame(list("sample_id"="Total", 
                    t(input_locus_summary %>%
   select(!!!rlang::syms(c(unique(db[['locus']]), "Total"))) %>%
   colSums(na.rm = T))))

input_locus_summary <- bind_rows(input_locus_summary, total)

subject_levels <- str_sort(unique(input_locus_summary$subject_id), numeric = TRUE)
sample_levels  <- str_sort(unique(input_locus_summary$sample_id),  numeric = TRUE)
input_locus_summary <- input_locus_summary %>%
  mutate(
    subject_id = factor(subject_id, levels = subject_levels),
    sample_id  = factor(sample_id,  levels = sample_levels)
  ) %>%
  arrange(subject_id, sample_id) %>%
  mutate(
    subject_id = as.character(subject_id),
    sample_id  = as.character(sample_id)
  )

tab_caption <- paste0("Input data. Number of sequences in each ", 
                   paste("sample", params$cloneby, sep=", "),
                   " and locus."
      )
eetable(input_locus_summary)$table
```
```{r echo=FALSE,results='asis'}
print_table_caption(tag="input_locus_summary", text=tab_caption)
```


```{r eval=any(db$locus %in% c("IGH")) & "c_call" %in% colnames(db) , results='asis'}
cat("## Sequences per constant region\n")
```

```{r input-cgene-summary, eval=any(db$locus %in% c("IGH")) & "c_call" %in% colnames(db) , results='asis'}

# Create c_gene column only for plotting (will be removed before storing the df again)
db <- db %>% filter(locus %in% c("IGH", "IGK", "IGL")) %>%
    mutate(c_gene = alakazam::getGene(c_call, first=TRUE)) %>%
    mutate(c_gene = substr(c_gene,1,4))

input_cgene_summary <- db %>%
  group_by(!!!rlang::syms(unique(c("sample_id", "subject_id", params$cloneby, "c_gene")))) %>%
   summarize(n=n(), .groups="drop") %>%
       pivot_wider(names_from=c_gene, values_from=n)

subject_levels <- str_sort(unique(input_cgene_summary$subject_id), numeric = TRUE)
sample_levels  <- str_sort(unique(input_cgene_summary$sample_id),  numeric = TRUE)
input_cgene_summary <- input_cgene_summary %>%
  mutate(
    subject_id = factor(subject_id, levels = subject_levels),
    sample_id  = factor(sample_id,  levels = sample_levels)
  ) %>%
  arrange(subject_id, sample_id)

tab_caption <- paste0("Input data. Number of sequences in each ", 
                   paste("sample", params$cloneby, sep=", "),
                   " and c_gene"
      )
eetable(input_cgene_summary)$table
```

```{r echo=FALSE, eval=any(db$locus %in% c("IGH")) & "c_call" %in% colnames(db), results='asis'}
print_table_caption(tag="input_cgene_summary", text=tab_caption)
```

# Clonal assignment

<div class="introduction_paragraph">
Clonal assignment is performed with the function `hierarchicalClones` from package <a href="https://scoper.readthedocs.io/en/stable/" target="_blank">SCOPer</a>. This approach clusters B or T cell receptor sequences based on junction region sequence similarity within partitions that share the same V gene, J gene, and junction length, allowing for ambiguous V or J gene annotations. By default, 'subject_id' is used for grouping samples before assigning clones. 
</div>

```{r, eval="clone_id" %in% colnames(db), results='asis', echo=FALSE}
cat("\n\nThe input data contains clonal assignments, and are being reused.")
```

```{r, child=c('run_scoper.Rmd'), eval=!"clone_id" %in% colnames(db)}
```

# Final repertoires and tables

Find your final repertoires here:

```{r fn, results='asis', echo=F}
# pass <- db[['collapse_pass']]

if (!is.null(params$outname)) {
    output_fn <- paste0(params$outname,"_clone-pass.tsv")
} else {
    output_fn <- sub(".tsv$", "_clone-pass.tsv", basename(params$input))
}

if (!is.null(params$log)) {
    log_fn <- file.path(params$outdir,paste0(params$log,".txt"))
} else {
    log_fn <- file.path(params$outdir,sub("_clone-pass.tsv$", "_command_log.txt", basename(output_fn)))
}
```

```{r dbpass, results='asis', echo=FALSE}

# collpase in case there are multiple rows
# due to multiple input files
input_sizes_byoutput <- input_sizes_byoutput %>%
    select(-input_files) %>%
    ungroup() %>%
    group_by(!!!rlang::syms(params$outputby)) %>%
    summarise(across(everything(), function(x) {paste(x, collapse = ",")} ))
    
output_groups <- db %>%
    ungroup() %>%
    select(!!!rlang::syms(c(params$outputby, "input_file"))) %>%
    group_by(!!!rlang::syms(params$outputby)) %>%
    summarize(output_size = n()) %>%
    right_join(input_sizes_byoutput) %>%
    select(input_size, output_size, everything()) 
    
   
output_files <- c()
output_sizes <- c()
input_sizes <- c()
dir.create(file.path(params$outdir, "repertoires"))
for (i in 1:nrow(output_groups)) {
  group_db <- left_join(output_groups[i, params$outputby, drop = F],
    db,
    by = c(params$outputby)
  )

  group_db_label <- gsub("^id_", "", makeLabel(group_db, fields = params$outputby))
  group_fn <- file.path(params$outdir, "repertoires", paste0(group_db_label, "_", output_fn))
  output_files <- c(output_files, group_fn)
  output_sizes <- c(output_sizes, nrow(group_db))
  i_input_size <- sum(as.numeric(strsplit(as.character(output_groups[["input_size"]][i]), ",")[[1]]))
  input_sizes <- c(input_sizes, i_input_size)
  write_rearrangement(group_db %>% select(-input_file), file = group_fn)
  cat("- [", group_db_label, "](", file.path("repertoires", basename(group_fn)), ")\n", sep = "")
}
```

```{r log, echo=FALSE}
cat("START> ClonePass", file=log_fn, append=F)
for (i in 1:nrow(output_groups)) {
    cat(paste0("\nFILE",i,"> ",basename(output_groups[['input_file']][i])), file=log_fn, append=T)
    cat(paste0("\nOUTPUT",i,"> ",basename(output_files[i])), file=log_fn, append=T)
    cat(paste0("\nPASS",i,"> ",output_sizes[i]), file=log_fn, append=T)
    cat(paste0("\nFAIL",i,"> ",input_sizes[i]-output_sizes[i]), file=log_fn, append=T)    
}
```

```{r, child=c('versions.Rmd')}
```