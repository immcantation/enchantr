[["index.html", "Immcantation - enchantR Clonal Assignment 1 Input parameters 2 Read repertoires 2.1 Sequences per locus 3 Clonal assignment 3.1 Create germlines 4 Clone size distribution 4.1 Number of clones 4.2 Clone size distribution without singletons 5 Clonal abundance 5.1 Abundance plot by sample 6 Diversity 6.1 Diversity curves 6.2 Diversity plot by sample 6.3 Diversity at different q 7 Mutation frequency 8 Final repertoires and tables 9 Software versions", " Immcantation - enchantR Clonal Assignment Updated: Fri Apr 4 12:00:41 2025 Report of clonal assignment, clone size distribution, clonal abundance, diversity and mutation frequency created by immcantation enchantR package. Immcantation package SCOPer is used to define clones. Package Alakazam is used for clonal abundance and diversity analysis. Package SHazaM is used for advanced analysis of somatic hypermutation (SHM). 1 Input parameters Code printParams(params) Table 1.1: Input parameters. 2 Read repertoires Tables summarizing repertoire distributions for each sample. Code # Read repertoire db &lt;- readInput(params[[&#39;input&#39;]], col_select = NULL) if (params$species ==&quot;auto&quot;) { if (&quot;species&quot; %in% colnames(db)) { species &lt;- unique(db[[&#39;species&#39;]]) if (length(species)&gt;1) { stop(&quot;Multiple species detected. Only one allowed.&quot;) } } else { stop(&quot;Can&#39;t detect species. The column `species` does not exist in `db`.&quot;) } } else { species &lt;- params$species } # Check for single cell label if (!is.null(singlecell)) { if (singlecell %in% colnames(db)) { db[[ singlecell ]] &lt;- as.logical(db[[ singlecell ]] ) } else { stop(&quot;`&quot;,singlecell, &quot;` is not a valid field in `db`.&quot;) } } else { singlecell &lt;- &quot;single_cell&quot; db[[singlecell]] &lt;- F if (&quot;cell_id&quot; %in% colnames(db)) { message(&quot;Setting `singlecell` using `cell_id`.&quot;) db[[singlecell]][!db[[&#39;cell_id&#39;]] %in% c(NA, &#39;&#39;)] &lt;- T } } if (!&quot;locus&quot; %in% colnames(db)) { db[[&#39;locus&#39;]] &lt;- getLocus(db[[&#39;v_call&#39;]]) } heavy_chains &lt;- isHeavyChain(db[[&#39;locus&#39;]]) if (&quot;clone_id&quot; %in% colnames(db)) { if (params$force) { # Reset if force warning(&quot;Overwritting clone_id.&quot;) db$clone_id &lt;- NULL } # Reset always if clone_id exists if (&quot;clone_size_count&quot; %in% colnames(db)) { warning(&quot;Overwritting clone_size_count.&quot;) db$clone_size_count &lt;- NULL } if (&quot;clone_size_freq&quot; %in% colnames(db)) { warning(&quot;Overwritting clone_size_freq.&quot;) db$clone_size_freq &lt;- NULL } } Code input_size &lt;- nrow(db) input_sizes &lt;- db %&gt;% group_by(!!!rlang::syms(unique(c(&quot;input_file&quot;)))) %&gt;% summarize(input_size=n()) # Track input size of the expected output groups, for the # end of report summary input_sizes_byoutput &lt;- db %&gt;% group_by(!!!rlang::syms(unique(params$outputby))) %&gt;% mutate( num_input_files = length(unique(input_file)), input_files = paste(unique(input_file), collapse=&quot;,&quot;) ) %&gt;% ungroup() %&gt;% group_by(!!!rlang::syms(unique(c(params$outputby, &quot;input_file&quot;, &quot;num_input_files&quot;, &quot;input_files&quot;)))) %&gt;% summarize( input_size = n() ) Number of sequences loaded: 3000. Number of heavy chain sequences loaded: 3000. Code input_samples_summary &lt;- db %&gt;% group_by(sample_id, subject_id, tissue) %&gt;% summarize(size = n()) %&gt;% arrange(subject_id) eetable(input_samples_summary)$table 2.1 Sequences per locus Code input_locus_summary &lt;- db %&gt;% group_by(!!!rlang::syms(unique(c(&quot;sample_id&quot;,params$cloneby, &quot;locus&quot;)))) %&gt;% summarize(n=n(), .groups=&quot;drop&quot;) %&gt;% pivot_wider(names_from=locus, values_from=n) %&gt;% rowwise() %&gt;% mutate(Total = sum(!!!rlang::syms(unique(db[[&#39;locus&#39;]])))) total &lt;- data.frame(list(&quot;sample_id&quot;=&quot;Total&quot;, t(input_locus_summary %&gt;% select(!!!rlang::syms(c(unique(db[[&#39;locus&#39;]]), &quot;Total&quot;))) %&gt;% colSums(na.rm = T)))) input_locus_summary &lt;- bind_rows(input_locus_summary, total) tab_caption &lt;- paste0(&quot;Input data. Number of sequences in each &quot;, paste(&quot;sample&quot;, params$cloneby, sep=&quot;, &quot;), &quot; and locus.&quot; ) eetable(input_locus_summary)$table Table 2.1: Input data. Number of sequences in each sample, subject_id and locus. Code cat(&quot;## Sequences per constant region\\n&quot;) Code # Create c_gene column only for plotting (will be removed before storing the df again) db &lt;- db %&gt;% filter(locus %in% c(&quot;IGH&quot;, &quot;IGK&quot;, &quot;IGL&quot;)) %&gt;% mutate(c_gene = alakazam::getGene(c_call, first=TRUE)) input_cgene_summary &lt;- db %&gt;% group_by(!!!rlang::syms(unique(c(&quot;sample_id&quot;,params$cloneby, &quot;c_gene&quot;)))) %&gt;% summarize(n=n(), .groups=&quot;drop&quot;) %&gt;% pivot_wider(names_from=c_gene, values_from=n) tab_caption &lt;- paste0(&quot;Input data. Number of sequences in each &quot;, paste(&quot;sample&quot;, params$cloneby, sep=&quot;, &quot;), &quot; and c_gene&quot; ) eetable(input_cgene_summary)$table 3 Clonal assignment Clonal assignment performed with scoper::hierarchicalClones.This approach clusters B or T cell receptor sequences based on junction region sequence similarity within partitions that share the same V gene, J gene, and junction length, allowing for ambiguous V or J gene annotations.By default, ’subject_id’is used for grouping. Sequences with different subject_id will be classified as separate clones. Clonal assignment performed with scoper::hierarchicalClones, version 1.3.0 within subject_id. To know more details about the method, visit the documentation website https://scoper.readthedocs.io/en/ Code if (sum(heavy_chains)&gt;0) { if (params$model == &quot;hierarchical&quot;) { if (all(db[[ singlecell ]] == T )) { cell_id &lt;- &#39;cell_id&#39; } else { db_light &lt;- db %&gt;% filter(!isHeavyChain(locus)) cell_id &lt;- NULL if (all(c(T,F) %in% db[[ singlecell ]])) { warning(&quot;Mix of single and bulk data. Setting cell_id=`NULL`.&quot;) } } db &lt;- hierarchicalClones(db, params$threshold, method=params$method, linkage=params$linkage, normalize=&quot;len&quot;, junction=&quot;junction&quot;, v_call=&quot;v_call&quot;, j_call=&quot;j_call&quot;, clone=&quot;clone_id&quot;, fields=params$cloneby, cell_id=cell_id, locus=&quot;locus&quot;, only_heavy=TRUE, split_light=TRUE, first=FALSE, cdr3=FALSE, mod3=FALSE, max_n=0, nproc=params$nproc, verbose=FALSE, log=NULL, summarize_clones=FALSE) } else { stop(&quot;Unsuported model requested. Supported models: hierarchical&quot;) } } else { warning(&quot;No heavy chain sequences found.&quot;) db$clone_id &lt;- NA } ## Warning in defineClonesScoper(db = db, threshold = threshold, model = ## &quot;hierarchical&quot;, : Single cell mode requested, but `db` doesn&#39;t contain light ## chain data. Skipping. 3000 sequences passed the clonal assignment step and 0 were removed. 0 sequences have clone_id==NA. 3.1 Create germlines Code dowser_v &lt;- packageVersion(&quot;dowser&quot;) Identification of the V(D)J germline sequences from which each of the observed sequences is derived is performed with dowser::createGermlines, version 2.3. These reconstructed germlines will be used in downstream analysis to infer somatic mutations and reconstruct lineages. dowser::createGermlines takes the alignment information in the rearrangement file as well as the reference database used by the alignment software and generates a germline sequence for each individual observed sequence. Because clonal relations have already been inferred, the function assigns the same germline to all sequences belonging to the same clone. Two types of germlines are created, germline_alignment and germline_alignment_d_mask. The last one has the D region masked, meaning that all nucleotides in the N/P and D-segments are replaced with N’s. This is often done because the germline base calls from this region are unreliable for B cell receptor alignments. Documentation for dowser::createGermlines is available here: https://dowser.readthedocs.io/en/latest/topics/createGermlines. Code pre_germ_size &lt;- nrow(db) db[[&#39;tmp_nrow&#39;]] &lt;- 1:nrow(db) # download and unzip if needed imgt_db &lt;- prepareIMGT(params$imgt_db) references &lt;- dowser::readIMGT(file.path(imgt_db, species, &quot;vdj&quot;), quiet=TRUE) ## [1] &quot;Read in 1199 from 17 fasta files&quot; Code # tmp fix (add unique sequence id ) for # Error in dowser::createGermlines(db_sp, references, locus = &quot;locus&quot;, : # Sequence IDs are not unique! dup_ids &lt;- db %&gt;% ungroup() %&gt;% group_by(!!!rlang::syms(c(params$cloneby))) %&gt;% mutate(dup=duplicated(sequence_id)) %&gt;% pull(dup) %&gt;% any() if (dup_ids) { db &lt;- db %&gt;% mutate(sequence_id = paste(sample_id, sequence_id, sep = &#39;_&#39;)) } is_na_clone &lt;- is.na(db[[&quot;clone_id&quot;]]) not_na_clone_db &lt;- data.frame() na_clone_db &lt;- data.frame() if (any(is_na_clone)) { na_clone_db &lt;- dowser::createGermlines( db[is_na_clone,,drop=FALSE], references, locus = &quot;locus&quot;, nproc = params$nproc, seq = &quot;sequence_alignment&quot;, v_call = &quot;v_call&quot;, d_call = &quot;d_call&quot;, j_call = &quot;j_call&quot;, amino_acid = FALSE, id = &quot;sequence_id&quot;, clone = &quot;tmp_nrow&quot;, v_germ_start = &quot;v_germline_start&quot;, v_germ_end = &quot;v_germline_end&quot;, v_germ_length = &quot;v_germline_length&quot;, d_germ_start = &quot;d_germline_start&quot;, d_germ_end = &quot;d_germline_end&quot;, d_germ_length = &quot;d_germline_length&quot;, j_germ_start = &quot;j_germline_start&quot;, j_germ_end = &quot;j_germline_end&quot;, j_germ_length = &quot;j_germline_length&quot;, np1_length = &quot;np1_length&quot;, np2_length = &quot;np2_length&quot;, na.rm = TRUE, fields = params$cloneby ) } if (any(!is_na_clone)) { not_na_clone_db &lt;- dowser::createGermlines( db[!is_na_clone,,drop=FALSE], references, locus = &quot;locus&quot;, nproc = params$nproc, seq = &quot;sequence_alignment&quot;, v_call = &quot;v_call&quot;, d_call = &quot;d_call&quot;, j_call = &quot;j_call&quot;, amino_acid = FALSE, id = &quot;sequence_id&quot;, clone = &quot;clone_id&quot;, v_germ_start = &quot;v_germline_start&quot;, v_germ_end = &quot;v_germline_end&quot;, v_germ_length = &quot;v_germline_length&quot;, d_germ_start = &quot;d_germline_start&quot;, d_germ_end = &quot;d_germline_end&quot;, d_germ_length = &quot;d_germline_length&quot;, j_germ_start = &quot;j_germline_start&quot;, j_germ_end = &quot;j_germline_end&quot;, j_germ_length = &quot;j_germline_length&quot;, np1_length = &quot;np1_length&quot;, np2_length = &quot;np2_length&quot;, na.rm = TRUE, fields = params$cloneby ) } db &lt;- bind_rows(not_na_clone_db, na_clone_db) %&gt;% arrange(tmp_nrow) %&gt;% select(-tmp_nrow) any_germ_fail &lt;- pre_germ_size &gt; nrow(db) 2998 sequences passed the germline reconstruction step and 2 failed. Code # Remove cells that after createGermlines # have only light chains db &lt;- findLightOnlyCells(db, sample_id = &quot;sample_id&quot;, cell_id = cell_id, locus = &quot;locus&quot;, fields = NULL) num_light_only &lt;- sum(db[[&quot;light_only_cell&quot;]], na.rm = T) if (num_light_only &gt; 0) { # Remove the cells db &lt;- db %&gt;% dplyr::filter(!light_only_cell) cat(paste0(&quot;Removed &quot;,num_light_only,&quot; sequences in light chain only cells.&quot;)) } db[[&quot;light_only_cell&quot;]] &lt;- NULL Code # Add again light chains before observed mutations when mixture of sc + bulk or only bulk if (nrow(db_light) &gt; 0){ db &lt;- bind_rows(db, db_light) } 4 Clone size distribution Find your clone sizes table here. Most real datasets, will have most clones of size 1 (one sequence). Straight sequence count as a measure of the size of the clones is not the best measure to compare clone size between samples due to possible disproportionate sampling. See the Clonal abundance section. Description of terms: clone_size_count: Clone size as sequence counts. In a sample (sample_id), the number of heavy chain sequences with the same clone_id. clone_size_freq: Clone size as percent of the repertoire. clone_size_count divided by the number of heavy chain sequences in the sample (sample_id). 4.1 Number of clones Summary of the number of clones base on heavy chain sequences, and clone size per sample. Singletons which are clone of single sequence are included in the table. Code # Add clone_size clone_sizes &lt;- countClones( db %&gt;% filter(isHeavyChain(locus)), # Keep heavy chains only groups=unique(c(&quot;sample_id&quot;, params$cloneby))) Code tmp &lt;- eetable(clone_sizes, caption=NULL, outdir=params$outdir, file=&quot;clone_sizes_table&quot;) db &lt;- db %&gt;% left_join(clone_sizes) %&gt;% rename( clone_size_count = seq_count, clone_size_freq = seq_freq ) %&gt;% mutate_at(vars(starts_with(&quot;clone_size&quot;)), round,2) Code num_clones_table &lt;- db %&gt;% filter(isHeavyChain(locus)) %&gt;% # Keep heavy chains only group_by(sample_id) %&gt;% mutate(sequences=n()) %&gt;% group_by(sample_id) %&gt;% mutate( number_of_clones=length(unique(clone_id)), ) %&gt;% group_by(!!!rlang::syms(unique(c(&quot;sample_id&quot;,&quot;sequences&quot;, params$cloneby, &quot;number_of_clones&quot;)))) %&gt;% summarize_at(vars(starts_with(&quot;clone_size&quot;)), list(&quot;min&quot;=min, &quot;median&quot;=median, &quot;max&quot;=max)) %&gt;% mutate_at(vars(starts_with(&quot;clone_size&quot;)), round, 2) tab_caption &lt;- &quot;Summary of the number of clones, and clone size, per sample. Includes singletons (clone_size == 1).&quot; tab &lt;- eetable(num_clones_table, caption=tab_caption, outdir=params$outdir, file=&quot;num_clones_table&quot;) tab$table Table 4.1: Summary of the number of clones, and clone size, per sample. Includes singletons (clone_size == 1). File can be found here: num_clones_table.tsv 4.2 Clone size distribution without singletons Plot of clone size distribution. In most cases, the majority of clones are singletons (clones consisting of a single sequence). To improve readability for non-singleton clones, singletons are excluded from the plot. Code caption &lt;- &quot;Clone size distribution, excluding singletons (subset to clone size &gt; 1). Size is measured as number of heavy chain sequences belonging to the same clone.&quot; clone_size_atleast2 &lt;- ggplot(clone_sizes %&gt;% filter(seq_count&gt;1), aes(x=seq_count, color=sample_id, fill=sample_id))+ geom_bar() + theme_enchantr() + facet_wrap(~sample_id, scales = &quot;free_y&quot;, ncol=3) + xlab(&quot;Clone size (Sequences per clone)&quot;) clone_size_atleast2 &lt;- eeplot(clone_size_atleast2, outdir=params$outdir, file=knitr::opts_current$get(&#39;clone-size_atleast2&#39;), caption=caption ) ggplotly(clone_size_atleast2 + theme(panel.spacing=unit(2, &#39;lines&#39;), legend.position=&quot;right&quot;)) Figure 4.1: Clone size distribution, excluding singletons (subset to clone size &gt; 1). Size is measured as number of heavy chain sequences belonging to the same clone. ggplot file: clone_size_atleast2.RData Code caption &lt;- clone_size_atleast2$enchantr$html_caption Code cat(&quot;Only singletons detected: there aren&#39;t clones of size&gt;1.\\n\\n&quot;) 5 Clonal abundance Clonal abundance is the size of each clone (as a fraction of the entire repertoire). To correct for the different number of sequences in each of the samples, estimateAbundance estimates the clonal abundance distribution along with confidence intervals on these clone sizes using bootstrapping. 200 random bootstrap samples were taken, with size the number of sequences in the sample with less sequences (N). The y-axis shows the clone abundance (i.e., the size as a percent of the repertoire) and the x-axis is a rank of each clone, where the rank is sorted by clone size from larger (rank 1, left) to smaller (right). The shaded areas are confidence intervals. Code # set empty default abundance a &lt;- new(&quot;AbundanceCurve&quot;) Code # calculate the rank-abundance curve a &lt;- estimateAbundance(db %&gt;% filter(isHeavyChain(locus)), group = &quot;sample_id&quot;, min_n = params$min_n) if (nrow(a@abundance)==0) { cat(&quot;\\nAll groups failed to pass the threshold min_n=&quot;,params$min_n,&quot;. Skipping clonal abundance report.\\n\\n&quot;) } Code # annotate a@abundance &lt;- a@abundance %&gt;% left_join( db %&gt;% select(any_of(c(unique(c(&quot;sample_id&quot;, &quot;subject_id&quot;, params$cloneby))) ) ) %&gt;% distinct(), ) p &lt;- plotAbundanceCurve(a, annotate=&quot;depth&quot;, silent = T) Code tab &lt;- eetable(a@abundance, file = &quot;clonal_abundance&quot;, outdir=params$outdir, show_max=10, caption=&quot;Example 10 lines of the clonal abundance file.&quot;) tab$table %&gt;% DT::formatRound(columns=c(&quot;p&quot;,&quot;p_sd&quot;,&quot;lower&quot;,&quot;upper&quot;),digits=3) Table 5.1: Example 10 lines of the clonal abundance file. File can be found here: clonal_abundance.tsv 5.1 Abundance plot by sample Code abundanceSample &lt;- p + facet_wrap(~ subject_id + sample_id, ncol=3) abundanceSample &lt;- eeplot(abundanceSample, outdir=params$outdir, file=knitr::opts_current$get(&#39;abundanceSample&#39;), caption=paste0(&quot;Clonal abundance plot per `sample_id`. Clonal abundance was calculated with a sample of N=&quot;, a@n, &quot; sequences with &quot;, a@nboot, &quot; boostrapping repetitions.&quot;), a) abundanceSample + theme(legend.position = &quot;none&quot;) Figure 5.1: Clonal abundance plot per sample_id. Clonal abundance was calculated with a sample of N=180 sequences with 200 boostrapping repetitions. ggplot file: abundanceSample.RData Code caption &lt;- abundanceSample$enchantr$html_caption 6 Diversity The clonal abundance distribution can be characterized using diversity statistics. Diversity scores (D) are calculated using the generalized diversity index (Hill numbers), which covers many different measures of diversity in a single function with a single varying parameter, the diversity order q. The function alphaDiversity resamples the sequences (200 random bootstrapping events, with the number of sequences in the sample with less sequences (N)) and calculates diversity scores (D) over a interval of diversity orders (q). The diversity (D) is shown on the y-axis and the x-axis is the parameter q. - q = 0 corresponds to Species Richness - q = 1 corresponds to Shannon Entropy - q = 2 corresponds to Simpson Index Inspection of this figure is useful to determine whether any difference in diversity between two repertoires depends on the statistic used or if it is a universal property. The clonal diversity \\(D\\) of the repertoire was calculated according to the general formula of Hill Diversity numbers: \\[ \\begin{aligned} ^{q}D = \\left( \\sum_{i=1}^Rp_i^q \\right)^{1/(1-q)} \\end{aligned} \\] where: \\(p_i\\) is the proportion of unique sequences belonging to clone \\(i\\). \\(q\\) are the values of the different diversity numbers. \\(R\\) is the Richness, the number of different clones in the sample. At \\(q=1\\) the function is undefined and the limit to zero equals the exponential of the Shannon Entropy: \\[ \\begin{aligned} ^{1}D = exp \\left( \\sum_{i=1}^Rp_i ln(p_i) \\right) \\end{aligned} \\] The intuition about the different Hill Diversity values is the following: At \\(q=0\\) the diversity index equals the number of clones in the sample. At \\(q=1\\) the diversity index is the geometric mean of the clones in the sample, weighted by their proportion in the sample. At \\(q&gt;1\\) more weight is given to the clones with higher proportions in the sample. 6.1 Diversity curves The following table shows the summary of the diversity calculations per sample. Code # generate the Hill diversity curve d &lt;- alphaDiversity(db %&gt;% filter(isHeavyChain(locus)), group = &quot;sample_id&quot;, min_n=params$min_n) d@diversity &lt;- d@diversity %&gt;% left_join( db %&gt;% select(any_of(c(unique(c(&quot;sample_id&quot;, &quot;subject_id&quot;, params$cloneby))) ) ) %&gt;% distinct(), ) diversitySample &lt;- plotDiversityCurve(d, silent = T, annotate=&quot;depth&quot;) tab &lt;- eetable(d@diversity, file = &quot;clonal_diversity&quot;, outdir=params$outdir, show_max=10, caption=&quot;Example 10 lines of the clonal diversity file.&quot;) tab$table %&gt;% DT::formatRound(columns=c(&quot;q&quot;,&quot;d&quot;,&quot;d_sd&quot;,&quot;d_lower&quot;, &quot;d_upper&quot;, &quot;e&quot;, &quot;e_lower&quot;, &quot;e_upper&quot;),digits=3) Table 6.1: Example 10 lines of the clonal diversity file. File can be found here: clonal_diversity.tsv 6.2 Diversity plot by sample Code # plot duplicated cells diversitySample &lt;- diversitySample + geom_vline(xintercept = c(0,1,2), color = &quot;grey50&quot;, linetype = &quot;dashed&quot;) + facet_wrap(~sample_id + subject_id, ncol=3, scales = &quot;free_x&quot;) diversitySample &lt;- eeplot(diversitySample, outdir=params$outdir, file=knitr::opts_current$get(&#39;label&#39;), caption=paste0(&quot;Clonal diversity per `sample_id`.Clonal diversity was calculated with a sample of N=&quot;, d@n, &quot; sequences with &quot;, a@nboot, &quot; boostrapping repetitions.&quot;), d) diversitySample + theme(legend.position = &quot;none&quot;) Figure 6.1: Clonal diversity per sample_id.Clonal diversity was calculated with a sample of N=180 sequences with 200 boostrapping repetitions. ggplot file: diversitySample.RData Code caption &lt;- diversitySample$enchantr$html_caption 6.3 Diversity at different q q=0 corresponds to Richness (number of different clones in the sample). q=1 corresponds to Shannon diversity. q=2 corresponds to Simpson diversity. Code # plot duplicated cells div_data &lt;- d@diversity %&gt;% dplyr::filter(q==0 | q==1 | q==2) div_at_q &lt;- ggplot(div_data, aes(x=q, y=d, color=sample_id)) + geom_point() + theme_enchantr() + scale_x_continuous(breaks= c(0,1,2)) div_at_q &lt;- eeplot(div_at_q, outdir=params$outdir, file=knitr::opts_current$get(&#39;label&#39;), caption=&quot;Diversity at different q values.&quot;, div_at_q) ggplotly(div_at_q) (#fig:div_at_q)Diversity at different q values. ggplot file: div_at_q.RData Code caption &lt;- div_at_q$enchantr$html_caption Code cat(&quot;# Mutation frequency\\n&quot;) 7 Mutation frequency Code db &lt;- shazam::observedMutations(db, sequenceColumn = &quot;sequence_alignment&quot;, germlineColumn = &quot;germline_alignment_d_mask&quot;, frequency = T, combine = T, nproc = params$nproc) Code cat(&quot;Showing mutation frequency per c_gene only if the `c_call` column is present.\\n&quot;) Showing mutation frequency per c_gene only if the c_call column is present. Code cat(&quot;The mutation frequency per sequence is stored in the final dataframes in the `mu_freq` column.\\n&quot;) The mutation frequency per sequence is stored in the final dataframes in the mu_freq column. Code db_cgene &lt;- db %&gt;% filter(!is.na(c_gene), !(is.na(mu_freq))) db_cgene$mu_freq &lt;- as.numeric(db_cgene$mu_freq) if (nrow(db_cgene) &gt; 0) { mufreqSample &lt;- ggplot(db_cgene, aes(x=c_gene, y=mu_freq, fill=c_gene)) + geom_boxplot() + facet_wrap(~ subject_id + sample_id, ncol=3, scales = &quot;free&quot;) + theme_enchantr() + theme(axis.text.x = element_text(angle = 45, hjust = 1)) mufreqSample &lt;- eeplot(mufreqSample, outdir=params$outdir, file=&#39;mutation_frequency_sample&#39;, caption=paste0(&quot;Mutation frequency per C gene per `sample_id`.&quot;), mufreqSample) print(mufreqSample + theme(legend.position = &quot;none&quot;)) caption &lt;- mufreqSample$enchantr$html_caption } Code db_locus &lt;- db %&gt;% filter(!is.na(locus), !is.na(mu_freq)) db_locus$mu_freq &lt;- as.numeric(db_locus$mu_freq) if (nrow(db_locus) &gt; 0) { mufreqSampleLocus &lt;- ggplot(db_locus, aes(x=locus, y=mu_freq, fill=locus)) + geom_boxplot() + facet_wrap(~ subject_id + sample_id, ncol=3, scales = &quot;free&quot;) + theme_enchantr() + theme(axis.text.x = element_text(angle = 45, hjust = 1)) mufreqSampleLocus &lt;- eeplot(mufreqSampleLocus, outdir=params$outdir, file=&#39;mutation_frequency_sample_locus&#39;, caption=paste0(&quot;Mutation frequency per locus per `sample_id`.&quot;), mufreqSampleLocus) print(mufreqSampleLocus + theme(legend.position = &quot;none&quot;)) caption &lt;- mufreqSampleLocus$enchantr$html_caption } 8 Final repertoires and tables Summary tables: Summary of number of clones Clone sizes table Clonal abundance Clonal diversity Find your final repertoires here: P05_FNA_0_Y1 P05_FNA_12_Y1 P05_FNA_2_0_Y1 P05_FNA_2_12_Y1 P05_FNA_2_28_Y1 P05_FNA_2_5_Y1 P05_FNA_2_60_Y1 P05_FNA_3_12_Y1 P05_FNA_3_28_Y1 P05_FNA_5_Y1 P05_FNA_60_Y1 9 Software versions Code sessionInfo() ## R version 4.4.3 (2025-02-28 ucrt) ## Platform: x86_64-w64-mingw32/x64 ## Running under: Windows 11 x64 (build 26100) ## ## Matrix products: default ## ## ## locale: ## [1] LC_COLLATE=English_United States.utf8 ## [2] LC_CTYPE=English_United States.utf8 ## [3] LC_MONETARY=English_United States.utf8 ## [4] LC_NUMERIC=C ## [5] LC_TIME=English_United States.utf8 ## ## time zone: America/New_York ## tzcode source: internal ## ## attached base packages: ## [1] grid stats graphics grDevices utils datasets methods ## [8] base ## ## other attached packages: ## [1] plotly_4.10.4 ComplexHeatmap_2.18.0 enchantr_0.1.20 ## [4] dowser_2.3 scoper_1.3.0 shazam_1.2.0 ## [7] alakazam_1.3.0 ggplot2_3.5.1 airr_1.5.0 ## [10] tidyr_1.3.1 dplyr_1.1.4 DT_0.33 ## ## loaded via a namespace (and not attached): ## [1] RColorBrewer_1.1-3 rstudioapi_0.17.1 ## [3] jsonlite_2.0.0 shape_1.4.6.1 ## [5] magrittr_2.0.3 farver_2.1.2 ## [7] rmarkdown_2.29 GlobalOptions_0.1.2 ## [9] fs_1.6.5 zlibbioc_1.52.0 ## [11] vctrs_0.6.5 memoise_2.0.1 ## [13] Rsamtools_2.22.0 ggtree_3.14.0 ## [15] htmltools_0.5.8.1 S4Arrays_1.6.0 ## [17] progress_1.2.3 curl_6.2.2 ## [19] SparseArray_1.6.2 gridGraphics_0.5-1 ## [21] sass_0.4.9 KernSmooth_2.23-26 ## [23] bslib_0.9.0 htmlwidgets_1.6.4 ## [25] cachem_1.1.0 GenomicAlignments_1.42.0 ## [27] igraph_2.1.4 lifecycle_1.0.4 ## [29] iterators_1.0.14 pkgconfig_2.0.3 ## [31] Matrix_1.7-2 R6_2.6.1 ## [33] fastmap_1.2.0 GenomeInfoDbData_1.2.13 ## [35] MatrixGenerics_1.18.1 clue_0.3-66 ## [37] digest_0.6.37 aplot_0.2.5 ## [39] colorspace_2.1-1 patchwork_1.3.0 ## [41] S4Vectors_0.44.0 crosstalk_1.2.1 ## [43] GenomicRanges_1.58.0 labeling_0.4.3 ## [45] phylotate_1.3 httr_1.4.7 ## [47] polyclip_1.10-7 abind_1.4-8 ## [49] compiler_4.4.3 bit64_4.6.0-1 ## [51] withr_3.0.2 doParallel_1.0.17 ## [53] BiocParallel_1.40.0 viridis_0.6.5 ## [55] ggforce_0.4.2 MASS_7.3-64 ## [57] DelayedArray_0.32.0 rjson_0.2.23 ## [59] tools_4.4.3 ape_5.8-1 ## [61] quadprog_1.5-8 glue_1.8.0 ## [63] nlme_3.1-167 cluster_2.1.8 ## [65] ade4_1.7-23 generics_0.1.3 ## [67] seqinr_4.2-36 gtable_0.3.6 ## [69] tzdb_0.5.0 data.table_1.17.0 ## [71] hms_1.1.3 tidygraph_1.3.1 ## [73] XVector_0.46.0 BiocGenerics_0.52.0 ## [75] ggrepel_0.9.6 foreach_1.5.2 ## [77] pillar_1.10.1 markdown_2.0 ## [79] stringr_1.5.1 vroom_1.6.5 ## [81] yulab.utils_0.2.0 circlize_0.4.16 ## [83] tweenr_2.0.3 treeio_1.30.0 ## [85] lattice_0.22-6 bit_4.6.0 ## [87] tidyselect_1.2.1 Biostrings_2.74.1 ## [89] knitr_1.50 gridExtra_2.3 ## [91] bookdown_0.42 IRanges_2.40.1 ## [93] SummarizedExperiment_1.36.0 stats4_4.4.3 ## [95] xfun_0.51 graphlayouts_1.2.2 ## [97] Biobase_2.66.0 diptest_0.77-1 ## [99] matrixStats_1.5.0 stringi_1.8.7 ## [101] UCSC.utils_1.2.0 lazyeval_0.2.2 ## [103] ggfun_0.1.8 yaml_2.3.10 ## [105] evaluate_1.0.3 codetools_0.2-20 ## [107] ggraph_2.2.1 tibble_3.2.1 ## [109] ggplotify_0.1.2 cli_3.6.4 ## [111] munsell_0.5.1 jquerylib_0.1.4 ## [113] Rcpp_1.0.14 GenomeInfoDb_1.42.3 ## [115] png_0.1-8 parallel_4.4.3 ## [117] readr_2.1.5 prettyunits_1.2.0 ## [119] bitops_1.0-9 phangorn_2.12.1 ## [121] viridisLite_0.4.2 tidytree_0.4.6 ## [123] scales_1.3.0 purrr_1.0.4 ## [125] crayon_1.5.3 GetoptLong_1.0.5 ## [127] rlang_1.1.5 fastmatch_1.1-6 "]]
