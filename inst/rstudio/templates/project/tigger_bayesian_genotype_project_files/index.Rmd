---
title: "Immcantation - enchantR"
subtitle: "TIgGER Bayesian genotype inference"
author: ""
date: "Updated: `r date()`"
knit: enchantr::render_book
site: bookdown::bookdown_site
documentclass: book
bibliography: "references.bib"
biblio-style: apalike
link-citations: yes
description: "enchantr TIgGER Bayesian genotype inference"
output: enchantr::immcantation
params:
   input:
      label: "`input`: Path to AIRR TSV file"
      input: file
      value: "https://yale.box.com/shared/static/dajikxtvbc3c5yw1o2v69fjtx5bh58r2.tsv"
   imgt_db:
      label: "`imgt_db`: Path to germline FASTA file"
      input: file
      value: "https://raw.githubusercontent.com/nf-core/test-datasets/airrflow/database-cache/imgtdb_base.zip"
   species:
      label: "`species`"
      input: text
      value: "human"
   call_column:
      label: "`call_column`: Column name of segment call (e.g., v_call)"
      input: text
      value: "v_call"
   seq_column:
      label: "`seq_column`: Column name of segment sequence (e.g., sequence_alignment)"
      input: text
      value: "sequence_alignment"
   germline_column:
      label: "`germline_column`: Column name of germline gene call (e.g., germline_alignment)"
      input: text
      value: "germline_alignment"
   clone_id_column:
      label: "`clone_id_column`: Column name of clone ID (e.g., clone_id)"
      input: text
      value: "clone_id"
   single_clone_representative:
      label: "`single_clone_representative`: Use single representative per clone"
      input: checkbox
      value: FALSE
   find_unmutated:
      label: "`find_unmutated`: Find unmutated sequences for genotype inference"
      input: checkbox
      value: FALSE
   single_assignments:
      label: "`single_assignments`: Filter to single gene assignments only"
      input: checkbox
      value: TRUE
   v_priors:
      label: "`v_priors`: V gene priors (comma-separated)"
      input: text
      value: "0.6,0.4,0.4,0.35,0.25,0.25,0.25,0.25,0.25"
   d_priors:
      label: "`d_priors`: D gene priors (comma-separated)"
      input: text
      value: "0.5,0.5,0,0,0,0,0,0,0"
   j_priors:
      label: "`j_priors`: J gene priors (comma-separated)"
      input: text
      value: "0.5,0.5,0,0,0,0,0,0,0"
   reassign:
      label: "`reassign`: Reassign sequences to personal genotype"
      input: checkbox
      value: FALSE
   outname:
      label: "`outname`"
      input: text
      value: "tigger"
   log:
      label: "`log`"
      input: text
      value: "command_log"
   outdir:
      label: "`outdir`: Output directory"
      input: text
      value: !r file.path(getwd(),'enchantr')
   date:
      label: "`date`: Run date"
      input: date
      value: !r format(Sys.time(), "%Y-%m-%d")
   logo:
      label: "`logo`: Path to report logo"
      input: file
      value: !r file.path("assets", "logo.png")
   logolink:
      label: "`logolink`: URL to be added to the logo"
      input: text
      value: "immcantation.org"
   echo:
      label: '`echo`: Show code in the report.'
      input: checkbox
      value: TRUE
   cache:
      label: '`cache`: Use cached results'
      input: checkbox
      value: FALSE
editor_options:
  chunk_output_type: console
---


<div class="introduction_paragraph">
Genotype inference determines the set of germline alleles carried by an individual for each immunoglobulin (IG) or T-cell receptor (TR) gene. 
Because repertoire sequencing captures rearranged V(D)J gene assignmentsrather than the germline loci themselves, an individual's true germline composition must be inferred from the distribution of unmutated or minimally mutated sequences observed across the repertoire. 
Accurate genotype inference corrects for missing or misassigned alleles in the reference database, ensuring that subsequent analyses—such as mutation quantification, lineage reconstruction, and repertoire comparison—are based on the subject’s actual germline profile.
</div>

```{r global-options, include=FALSE, cache=FALSE}
knitr::opts_chunk$set(fig.width=7, fig.height=4, fig.path = "figures/",
                      echo=params$echo,cache=params$cache,
                      warning=FALSE, message=FALSE,
                      eval.after="fig.cap",
                      out_dir=params$outdir,
                      eval.opts = c('eval', 'echo', 'fig.height', 'fig.width'))

# Libraries
suppressPackageStartupMessages(library("dplyr"))
suppressPackageStartupMessages(library("stringr"))
suppressPackageStartupMessages(library("tidyr"))
suppressPackageStartupMessages(library("airr"))
suppressPackageStartupMessages(library("enchantr"))
suppressPackageStartupMessages(library("tigger"))

if (!dir.exists(params$outdir)) {
    dir.create(params$outdir, recursive=T)
}

file.copy(params$logo,
          file.path(params$outdir,"assets", "logo.png"),
          recursive=T, overwrite=T)

```

```{r helper-functions, include=FALSE, cache=FALSE}

# Helper function to get most likely genotyped alleles
GENOTYPED_ALLELES <- function(y) {
  m <- which.max(as.numeric(y[2:5]))
  paste0(unlist(strsplit(y[1], ","))[1:m], collapse = ",")
}

```

# Input parameters

```{r input-parameters, results='asis'}
printParams(params)
```
```{r echo=FALSE, results='asis'}
print_table_caption(tag="input", text="Input parameters.")
save(params, file=file.path(params$outdir,"params.RData"))
```

# Read repertoire data

Load repertoire annotation tables in AIRR format.
Expected columns include `sequence_id`, `productive`, `v_call` / `d_call` / `j_call`,  `sequence_alignment`. Only productive, in-frame sequences without stop codons are retained to avoid artefacts.


```{r read-input}
# Read repertoire data
cols_to_read <- unique(c("sequence_id", "productive", "sequence_alignment", params$call_column))

db <- read_rearrangement(params$input, col_select = cols_to_read)

# Convert boolean parameters
find_unmutated <- params$find_unmutated
single_assignments <- params$single_assignments
call_col <- params$call_column

# Filter to productive sequences
db <- db %>% dplyr::filter(.data[['productive']] == TRUE)

# Filter to single assignments if requested
if (single_assignments) {
  db <- db[!grepl(",", db[[call_col]]), ]
}

# Remove NA values
db <- db[!is.na(db[[call_col]]), ]

# Set up output filenames
if (!is.null(params$outname)) {
   outname <- basename(params$outname)
   output_fn <- paste0(outname, "_reassigned-pass.tsv.gz")
   report_output_fn <- paste0(outname, "_", call_col , "_genotype_report.tsv")
   ref_output_fn <- paste0(outname, "_personal_reference.fasta")
} else {
   base <- sub(".tsv$", "", basename(params$input))
   output_fn <- paste0(base, "_reassigned-pass.tsv.gz")
   report_output_fn <- paste0(base, "_", call_col, "_genotype_report.tsv")
   ref_output_fn <- paste0(base, "_", call_col, "_personal_reference.fasta")
}

if (!is.null(params$log)) {
    log_fn <- paste0(params$log, ".txt")
} else {
    log_fn <- sub("_genotype_report.tsv$", "_command_log.txt", basename(output_fn))
}

```

# Read germline database

Import the nucleotide germline reference used for alignment.
Using the same reference ensures positional numbering and mutation counts remain consistent with the upstream alignment step. Each allele call present in the repertoire should have a corresponding entry in the germline database.


```{r read-germline}

loci <- unique(db[["locus"]])

# Handle germline database input
if (params$imgt_db != "") {
    # If it is a zip file or URL, run prepareIMGT; else use as is
    if (grepl("\\.zip$", params$imgt_db) || grepl("^https?://", params$imgt_db)) {
       imgt_db <- prepareIMGT(params$imgt_db)
       germline_db <- dowser::readIMGT(file.path(imgt_db, params$species, "vdj"), quiet=TRUE)
       germline_db <- unlist(lapply(loci, function(locus) germline_db[[locus]][[toupper(substr(params$call_col, 1, 1))]]))
    } else {
       germline_db <- tigger::readIgFasta(params$imgt_db)
    }
} else {
    germline_db <- NA
}

```


# Clonal representative selection (optional)

When multiple sequences originate from the same clone, they can inflate allele counts and bias genotype inference. If enabled, one representative sequence is selected per clone to represent that lineage in the analysis. This reduces the impact of clonal expansion, ensuring that allele frequencies reflect genuine germline variation rather than overrepresented clones, and minimizes noise from somatic hypermutation and sampling redundancy.

```{r clonal-representatives, eval=params$single_clone_representative}
if (params$single_clone_representative) {
   # Check that clone_id_column is provided
   if (is.null(params$clone_id_column) || params$clone_id_column == "") {
      stop("Error: 'clone_id_column' parameter must be provided when 'single_clone_representative' is TRUE.")
   }
   # Select clonal representatives
   db <- select_clonal_representatives(db,
                                       sequence_col = params$seq_column,
                                       germline_col = params$germline_column,
                                       clone_id_col = params$clone_id_column,
                                       return_count = FALSE)
   db <- db %>% filter(clone_representative)
}
```   

# Start log
```{r log-start}
cat("START> TIgGER Bayesian Genotype Inference", file=log_fn, append=F)
cat(paste0("\nMETHOD> TIgGER Bayesian"), file=log_fn, append=T)
cat(paste0("\nFILE> ",basename(params$input)), file=log_fn, append=T)
cat(paste0("\nCALL_COLUMN> ", params$call_column), file=log_fn, append=T)
```

# TIgGER Bayesian genotype inference


The `inferGenotypeBayesian` function applies a Bayesian framework to infer subject-specific germline genotypes from observed V(D)J gene assignments.
Allele usage is modeled as a multinomial distribution with a Dirichlet prior, empirically parameterized from high-coverage reference genotypes.

For each gene, the method evaluates all possible configurations of up to four alleles and calculates their posterior probabilities. Model certainty is expressed as a Bayes factor (K), representing the ratio between the likelihoods of the best and second-best models larger K values indicate stronger support for the inferred zygosity and allele composition.

This probabilistic approach incorporates prior expectations of allele frequencies within each gene family and accounts for sequencing depth variation, ambiguous V assignments, and low-frequency alleles. Together, these features yield quantitative, confidence-weighted genotype calls that form the basis for building a personalized germline reference.

```{r tigger-genotype-inference}

# Parse priors from parameters
priors <- list(
  v_call = as.numeric(strsplit(params$v_priors, ",")[[1]]),
  d_call = as.numeric(strsplit(params$d_priors, ",")[[1]]),
  j_call = as.numeric(strsplit(params$j_priors, ",")[[1]])
)

# Run TIgGER Bayesian genotype inference
geno <- try(tigger::inferGenotypeBayesian(
    db,
    find_unmutated = find_unmutated,
    germline_db = if (!all(is.na(germline_db))) germline_db else NULL,
    v_call = call_col,
    seq = params$seq_column,
    priors = priors[[call_col]]
))

stopifnot(!inherits(geno, "try-error"))

```

# Process genotype results

We extract the most likely alleles per gene using GENOTYPED_ALLELES, summarizing the Bayesian genotype output. The table lists each gene with its inferred alleles, supporting counts, and confidence metrics (log-likelihoods and Bayes factors).
This step produces a concise summary of the subject’s inferred genotype for downstream reference building.

```{r process-results}

# Determine most likely genotyped alleles
geno$genotyped_alleles <- apply(geno[, c(2, 6:9)], 1, GENOTYPED_ALLELES)

# Display results summary
tab_caption <- paste("TIgGER Bayesian genotype inference results showing inferred genotypes for",
                     nrow(geno), "genes.")

tab <- eetable(geno,
               caption = tab_caption,
               outdir = params$outdir,
               file = "genotype_results")
tab$table

caption <- tab$enchantr$html_caption

```

# Build personal reference

We start from the full germline DB:
- For genes present in the genotype table, we remove all their alleles, then add back only the alleles validated by genotype (genotyped_alleles if set; otherwise the inferred alleles).
- For genes absent from the genotype table, we keep all alleles as in the original DB.

This yields a personal reference restricted to genotype-validated alleles for seen genes, while leaving unseen genes unchanged.

```{r build-reference}

if (!all(is.na(germline_db))) {
   # Build personal reference database
   # Remove genes that were genotyped
   NOTGENO.IND <- !(sapply(strsplit(names(germline_db), "*", fixed = TRUE), `[`, 1) %in% geno$gene)
   germline_db_new <- germline_db[NOTGENO.IND]

   # Add genotyped alleles
   for (i in seq_len(nrow(geno))) {
        gene <- geno[i, "gene"]
        alleles <- if (geno[i, "genotyped_alleles"] == "") geno[i, "alleles"] else geno[i, "genotyped_alleles"]
        alleles <- unlist(strsplit(alleles, ","))
        IND <- names(germline_db) %in% paste(gene, alleles, sep = "*")
        germline_db_new <- c(germline_db_new, germline_db[IND])
    }
}

```



# Reassign sequences to personal genotype (optional)

If enabled, sequences are re-aligned to the updated germline database of the personal genotype alleles in the repertoire annotations.

For re-alignment the `reassignAlleles` function from TIgGER is used. The function utilizes hamming distance on the gapped sequence (i.e `sequence_alignment`), in order to save time, initial gene assignments are preserved and the allele calls are chosen from among those provided in `germline_db_new`, based on a simple alignment to the sample sequence.

```{r reassign, eval=params$reassign}
if (params$reassign & !all(is.na(germline_db))) {
   # Read rearrangement data with all columns
   db <- read_rearrangement(params$input)

   # Reassign sequences to personal genotype
   # TODO: check to add the option of path to aligner, and keep_gene
   # Using default params for now
   db <- reassignAlleles(db, 
                         genotype_db = germline_db_new,
                         v_call = call_col, 
                         seq = params$seq_column)
}
```


# Save results

```{r save-results}

# Save genotype report
write.table(geno,
           file = file.path(params$outdir, report_output_fn),
           sep = "\t",
           quote = FALSE,
           row.names = FALSE)

# Save personal reference if generated
if (!all(is.na(germline_db)) && exists("germline_db_new")) {
    tigger::writeFasta(germline_db_new,
                      file = file.path(params$outdir, ref_output_fn))
}

# Save reassigned database if generated
if (params$reassign & exists("db")) {
   write_rearrangement(db, 
                       file = file.path(params$outdir, output_fn))
}

```

```{r log-end}
cat("\nEND> TIgGER Bayesian Genotype Inference", file=log_fn, append=TRUE)
if(params$reassign && exists("db")){
   cat(paste0("\nOUTPUT> ", output_fn), file=log_fn, append=TRUE)
}
cat(paste0("\nOUTPUT> ", report_output_fn), file=log_fn, append=TRUE)
if (!all(is.na(germline_db)) && exists("germline_db_new")) {
    cat(paste0("\nOUTPUT> ", ref_output_fn), file=log_fn, append=TRUE)
}
cat(paste0("\nGENES_GENOTYPED> ", nrow(geno)), file=log_fn, append=TRUE)
```


```{r, eval=FALSE, echo=FALSE}
# TODO: add interactive genotype plot
```

```{r, child=c('versions.Rmd')}
```